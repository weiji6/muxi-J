1.布尔型的值只可以是常量 true 或者 false
当相等运算符两边的值是完全相同的值的时候会返回 true，否则返回 false，并且只有在两个的值的类型相同的情况下才可以使用
如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较
布尔型的常量和变量也可以通过和逻辑运算符（非 !、和 &&、或 ||）结合来产生另外一个布尔值，这样的逻辑语句就其本身而言，并不是一个完整的 Go 语句。

非运算符：!
```go
!T -> false
!F -> true
```go
非运算符用于取得和布尔值相反的结果

和运算符：&&
```go
T && T -> true
T && F -> false
F && T -> false
F && F -> false
```go
只有当两边的值都为 true 的时候，和运算符的结果才是 true。

或运算符：||
```go
T || T -> true
T || F -> true
F || T -> true
F || F -> false
```go
bool的格式化输出符为%t

2.数字类型
(i)int和float
与操作系统架构无关的类型都有固定的大小，并在类型的名称中就可以看出来：
整数：
int8（-128 -> 127）
int16（-32768 -> 32767）
int32（-2,147,483,648 -> 2,147,483,647）
int64（-9,223,372,036,854,775,808 -> 9,223,372,036,854,775,807）

无符号整数：
uint8（0 -> 255）
uint16（0 -> 65,535）
uint32（0 -> 4,294,967,295）
uint64（0 -> 18,446,744,073,709,551,615）

浮点型（IEEE-754 标准）：
float32（+- 1e-45 -> +- 3.4 * 1e38）
float64（+- 5 * 1e-324 -> 107 * 1e308）

可以使用 a := uint64(0) 来同时完成类型转换和赋值操作，这样 a 的类型就是 uint64。
格式化说明符：
在格式化字符串里，%d 用于格式化整数（%x 和 %X 用于格式化 16 进制表示的数字），%g 用于格式化浮点型（%f 输出浮点数，%e 输出科学计数表示法），%0d 用于规定输出定长的整数，其中开头的数字 0 是必须的。
%n.mg 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串%5.2e 来输出 3.4 的结果为 3.40e+00

(ii)复数
Go 拥有以下复数类型：
complex64 (32 位实数和虚数)
complex128 (64 位实数和虚数)

复数使用 re+imI 来表示，其中 re 代表实数部分，im 代表虚数部分，I 代表根号负 1。
函数 real(c) 和 imag(c) 可以分别获得相应的实数和虚数部分
在使用格式化说明符时，可以使用 %v 来表示复数，但当你希望只表示其中的一个部分的时候需要使用 %f

(iii)位运算
二元运算符
位运算只能用于整数类型的变量，且需当它们拥有等长位模式时。
%b 是用于表示位的格式化标识符。

对应位置上的值经过和运算结果，将 T（true）替换为 1，将 F（false）替换为 0
按位与 &：
```go
1 & 1 -> 1
1 & 0 -> 0
0 & 1 -> 0
0 & 0 -> 0
```go

对应位置上的值经过或运算结果，将 T（true）替换为 1，将 F（false）替换为 0
按位或 |：
```go
1 | 1 -> 1
1 | 0 -> 1
0 | 1 -> 1
0 | 0 -> 0
```go

按位异或 ^：
```go
1 ^ 1 -> 0
1 ^ 0 -> 1
0 ^ 1 -> 1
0 ^ 0 -> 0
```go

位清除 &^：将指定位置上的值设置为 0

一元运算符
按位补足 ^：
该运算符与异或运算符一同使用，即 m^x，对于无符号 x 使用“全部位设置为 1”，对于有符号 x 时使用 m=-1。例如：
```go
^2 = ^10 = -01 ^ 10 = -11
```go

位左移 <<：
用法：bitP << n。
bitP 的位向左移动 n 位，右侧空白部分使用 0 填充；如果 n 等于 2，则结果是 2 的相应倍数，即 2 的 n 次方。例如：
```go
1 << 10 // 等于 1 KB
1 << 20 // 等于 1 MB
1 << 30 // 等于 1 GB
```go

位右移 >>：
用法：bitP >> n。
bitP 的位向右移动 n 位，左侧空白部分使用 0 填充；如果 n 等于 2，则结果是当前值除以 2 的 n 次方。

当希望把结果赋值给第一个操作数时，可以简写为 a <<= 2 或者 b ^= a & 0xffffffff。

(iv)逻辑运算符
Go 中拥有以下逻辑运算符：==、!=、<、<=、>、>=。
它们之所以被称为逻辑运算符是因为它们的运算结果总是为布尔值 bool。例如：
```go
b3:= 10 > 5 // b3 is true
```go

(v)算数运算符
语句 b = b + a 简写为 b+=a，同样的写法也可用于 -=、*=、/=、%=。

对于整数和浮点数，你可以使用一元运算符 ++（递增）和 --（递减），但只能用于后缀

(vi)随机数
```go
package main
import (
    "fmt"
    "math/rand" //调用伪随机数包
    "time"
)

func main() {
    for i := 0; i < 10; i++ { //生成十个随机数//
        a := rand.Int()
        fmt.Printf("%d / ", a)
    }
    for i := 0; i < 5; i++ { //生成五个0到7之间的随机整数 
        r := rand.Intn(8) //rand.Intn(8)会返回一个小于8的非负整数
        fmt.Printf("%d / ", r)
    }
    fmt.Println()
    timens := int64(time.Now().Nanosecond()) //使用当前时间的纳秒部分设置种子确保每次运行生成的数组不同
    rand.Seed(timens)
    for i := 0; i < 10; i++ {
        fmt.Printf("%2.2f / ", 100*rand.Float32())
    }
}
```go

3.运算符与优先级
有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：
```go
优先级   运算符
 7      ^ !
 6      * / % << >> & &^
 5      + - | ^
 4      == != < <= >= >
 3      <-
 2      &&
 1      ||
 ```go

 4.类型别名
 当你在使用某个类型时，你可以给它起另一个名字，然后你就可以在你的代码中使用新的名字（用于简化名称或解决名称冲突）。
在 type TZ int 中，TZ 就是 int 类型的新名称（用于表示程序中的时区），然后就可以使用 TZ 来操作 int 类型的数据。

5.字符类型
这并不是 Go 语言的一个类型，字符只是整数的特殊用例